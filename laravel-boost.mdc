---
alwaysApply: true
---

<laravel-boost-guidelines>

=== foundation rules ===



# Laravel Boost Guidelines



The Laravel Boost guidelines are specifically curated by Laravel maintainers for this application. These guidelines should be followed closely to enhance the user's satisfaction building Laravel applications.



## Foundational Context

This application is a Laravel application and its main Laravel ecosystems package & versions are below. You are an expert with them all. Ensure you abide by these specific packages & versions.



- php - 8.4.14

- laravel/framework (LARAVEL) - v12

- laravel/passport (PASSPORT) - v13

- laravel/prompts (PROMPTS) - v0

- laravel/mcp (MCP) - v0

- laravel/pint (PINT) - v1

- laravel/sail (SAIL) - v1

- phpunit/phpunit (PHPUNIT) - v11

- alpinejs (ALPINEJS) - v3

- tailwindcss (TAILWINDCSS) - v3





## Conventions

- You must follow all existing code conventions used in this application. When creating or editing a file, check sibling files for the correct structure, approach, naming.

- Use descriptive names for variables and methods. For example, `isRegisteredForDiscounts`, not `discount()`.

- Check for existing components to reuse before writing a new one.



## Verification Scripts

- Do not create verification scripts or tinker when tests cover that functionality and prove it works. Unit and feature tests are more important.



## Application Structure & Architecture

- Stick to existing directory structure - don't create new base folders without approval.

- Do not change the application's dependencies without approval.



## Frontend Bundling

- If the user doesn't see a frontend change reflected in the UI, it could mean they need to run `npm run build`, `npm run dev`, or `composer run dev`. Ask them.



## Replies

- Be concise in your explanations - focus on what's important rather than explaining obvious details.



## Documentation Files

- You must only create documentation files if explicitly requested by the user.





=== boost rules ===



## Laravel Boost

- Laravel Boost is an MCP server that comes with powerful tools designed specifically for this application. Use them.



## Artisan

- Use the `list-artisan-commands` tool when you need to call an Artisan command to double check the available parameters.



## URLs

- Whenever you share a project URL with the user you should use the `get-absolute-url` tool to ensure you're using the correct scheme, domain / IP, and port.



## Tinker / Debugging

- You should use the `tinker` tool when you need to execute PHP to debug code or query Eloquent models directly.

- Use the `database-query` tool when you only need to read from the database.



## Reading Browser Logs With the `browser-logs` Tool

- You can read browser logs, errors, and exceptions using the `browser-logs` tool from Boost.

- Only recent browser logs will be useful - ignore old logs.



## Searching Documentation (Critically Important)

- Boost comes with a powerful `search-docs` tool you should use before any other approaches. This tool automatically passes a list of installed packages and their versions to the remote Boost API, so it returns only version-specific documentation specific for the user's circumstance. You should pass an array of packages to filter on if you know you need docs for particular packages.

- The 'search-docs' tool is perfect for all Laravel related packages, including Laravel, Inertia, Livewire, Filament, Tailwind, Pest, Nova, Nightwatch, etc.

- You must use this tool to search for Laravel-ecosystem documentation before falling back to other approaches.

- Search the documentation before making code changes to ensure we are taking the correct approach.

- Use multiple, broad, simple, topic based queries to start. For example: `['rate limiting', 'routing rate limiting', 'routing']`.

- Do not add package names to queries - package information is already shared. For example, use `test resource table`, not `filament 4 test resource table`.



### Available Search Syntax

- You can and should pass multiple queries at once. The most relevant results will be returned first.



1. Simple Word Searches with auto-stemming - query=authentication - finds 'authenticate' and 'auth'

2. Multiple Words (AND Logic) - query=rate limit - finds knowledge containing both "rate" AND "limit"

3. Quoted Phrases (Exact Position) - query="infinite scroll" - Words must be adjacent and in that order

4. Mixed Queries - query=middleware "rate limit" - "middleware" AND exact phrase "rate limit"

5. Multiple Queries - queries=["authentication", "middleware"] - ANY of these terms





=== php rules ===



## PHP



- Always use curly braces for control structures, even if it has one line.



### Constructors

- Use PHP 8 constructor property promotion in `__construct()`.

    - <code-snippet>public function __construct(public GitHub $github) { }</code-snippet>

- Do not allow empty `__construct()` methods with zero parameters.



### Type Declarations

- Always use explicit return type declarations for methods and functions.

- Use appropriate PHP type hints for method parameters.



<code-snippet name="Explicit Return Types and Method Params" lang="php">

protected function isAccessible(User $user, ?string $path = null): bool

{

    ...

}

</code-snippet>



## Comments

- Prefer PHPDoc blocks over comments. Never use comments within the code itself unless there is something _very_ complex going on.



## PHPDoc Blocks

- Add useful array shape type definitions for arrays when appropriate.



## Enums

- Typically, keys in an Enum should be TitleCase. For example: `FavoritePerson`, `BestLake`, `Monthly`.





=== laravel/core rules ===



## Do Things the Laravel Way



- Use `php artisan make:` commands to create new files (i.e. migrations, controllers, models, etc.). You can list available Artisan commands using the `list-artisan-commands` tool.

- If you're creating a generic PHP class, use `artisan make:class`.

- Pass `--no-interaction` to all Artisan commands to ensure they work without user input. You should also pass the correct `--options` to ensure correct behavior.



### Database

- Always use proper Eloquent relationship methods with return type hints. Prefer relationship methods over raw queries or manual joins.

- Use Eloquent models and relationships before suggesting raw database queries

- Avoid `DB::`; prefer `Model::query()`. Generate code that leverages Laravel's ORM capabilities rather than bypassing them.

- Generate code that prevents N+1 query problems by using eager loading.

- Use Laravel's query builder for very complex database operations.



### Model Creation

- When creating new models, create useful factories and seeders for them too. Ask the user if they need any other things, using `list-artisan-commands` to check the available options to `php artisan make:model`.



### APIs & Eloquent Resources

- For APIs, default to using Eloquent API Resources and API versioning unless existing API routes do not, then you should follow existing application convention.



### Controllers & Validation

- Always create Form Request classes for validation rather than inline validation in controllers. Include both validation rules and custom error messages.

- Check sibling Form Requests to see if the application uses array or string based validation rules.



### Queues

- Use queued jobs for time-consuming operations with the `ShouldQueue` interface.



### Authentication & Authorization

- Use Laravel's built-in authentication and authorization features (gates, policies, Sanctum, etc.).



### URL Generation

- When generating links to other pages, prefer named routes and the `route()` function.



### Configuration

- Use environment variables only in configuration files - never use the `env()` function directly outside of config files. Always use `config('app.name')`, not `env('APP_NAME')`.



### Testing

- When creating models for tests, use the factories for the models. Check if the factory has custom states that can be used before manually setting up the model.

- Faker: Use methods such as `$this->faker->word()` or `fake()->randomDigit()`. Follow existing conventions whether to use `$this->faker` or `fake()`.

- When creating tests, make use of `php artisan make:test [options] <name>` to create a feature test, and pass `--unit` to create a unit test. Most tests should be feature tests.



### Vite Error

- If you receive an "Illuminate\Foundation\ViteException: Unable to locate file in Vite manifest" error, you can run `npm run build` or ask the user to run `npm run dev` or `composer run dev`.





=== laravel/v12 rules ===



## Laravel 12



- Use the `search-docs` tool to get version specific documentation.

- Since Laravel 11, Laravel has a new streamlined file structure which this project uses.



### Laravel 12 Structure

- No middleware files in `app/Http/Middleware/`.

- `bootstrap/app.php` is the file to register middleware, exceptions, and routing files.

- `bootstrap/providers.php` contains application specific service providers.

- **No app\Console\Kernel.php** - use `bootstrap/app.php` or `routes/console.php` for console configuration.

- **Commands auto-register** - files in `app/Console/Commands/` are automatically available and do not require manual registration.



### Database

- When modifying a column, the migration must include all of the attributes that were previously defined on the column. Otherwise, they will be dropped and lost.

- Laravel 11 allows limiting eagerly loaded records natively, without external packages: `$query->latest()->limit(10);`.



### Models

- Casts can and likely should be set in a `casts()` method on a model rather than the `$casts` property. Follow existing conventions from other models.





=== pint/core rules ===



## Laravel Pint Code Formatter



- You must run `vendor/bin/pint --dirty` before finalizing changes to ensure your code matches the project's expected style.

- Do not run `vendor/bin/pint --test`, simply run `vendor/bin/pint` to fix any formatting issues.





=== phpunit/core rules ===



## PHPUnit Core



- This application uses PHPUnit for testing. All tests must be written as PHPUnit classes. Use `php artisan make:test --phpunit <name>` to create a new test.

- If you see a test using "Pest", convert it to PHPUnit.

- Every time a test has been updated, run that singular test.

- When the tests relating to your feature are passing, ask the user if they would like to also run the entire test suite to make sure everything is still passing.

- Tests should test all of the happy paths, failure paths, and weird paths.

- You must not remove any tests or test files from the tests directory without approval. These are not temporary or helper files, these are core to the application.



### Running Tests

- Run the minimal number of tests, using an appropriate filter, before finalizing.

- To run all tests: `php artisan test`.

- To run all tests in a file: `php artisan test tests/Feature/ExampleTest.php`.

- To filter on a particular test name: `php artisan test --filter=testName` (recommended after making a change to a related file).





=== tailwindcss/core rules ===



## Tailwind Core



- Use Tailwind CSS classes to style HTML, check and use existing tailwind conventions within the project before writing your own.

- Offer to extract repeated patterns into components that match the project's conventions (i.e. Blade, JSX, Vue, etc..)

- Think through class placement, order, priority, and defaults - remove redundant classes, add classes to parent or child carefully to limit repetition, group elements logically

- You can use the `search-docs` tool to get exact examples from the official documentation when needed.



### Spacing

- When listing items, use gap utilities for spacing, don't use margins.



    <code-snippet name="Valid Flex Gap Spacing Example" lang="html">

        <div class="flex gap-8">

            <div>Superior</div>

            <div>Michigan</div>

            <div>Erie</div>

        </div>

    </code-snippet>





### Dark Mode

- If existing pages and components support dark mode, new pages and components must support dark mode in a similar way, typically using `dark:`.





=== tailwindcss/v3 rules ===



## Tailwind 3



- Always use Tailwind CSS v3 - verify you're using only classes supported by this version.





=== service-repository-pattern rules ===



## Service-Repository Pattern



This application follows the Service-Repository pattern for clean architecture and separation of concerns.



### Architecture Overview

- **Controllers** handle HTTP requests/responses only

- **Services** contain business logic and orchestrate operations

- **Repositories** handle data access and database operations

- **Interfaces** define contracts for dependency inversion



### Folder Structure

```

app/

├── Http/Controllers/     # HTTP layer - thin controllers

├── Services/           # Business logic layer

│   ├── Contracts/      # Service interfaces

│   └── *.php          # Service implementations

├── Repositories/       # Data access layer

│   ├── Contracts/     # Repository interfaces

│   └── *.php         # Repository implementations

├── Adapters/          # External system adapters

│   ├── Contracts/    # Adapter interfaces

│   └── *.php         # Adapter implementations

└── Providers/         # Service container bindings

```



### Service Layer Rules

- Services should be `final readonly` classes

- Services implement interfaces for testability

- Services handle business logic, validation, and orchestration

- Services can depend on repositories and adapters

- Use constructor property promotion for dependencies



<code-snippet name="Service Implementation" lang="php">

final readonly class AuthService implements AuthServiceInterface

{

    public function __construct(

        private UserRepositoryInterface $userRepository,

        private TokenAdapterInterface $tokenAdapter,

    ) {

    }



    public function register(string $name, string $email, string $password): array

    {

        // Business logic here

    }

}

</code-snippet>



### Repository Layer Rules

- Repositories should be `final readonly` classes

- Repositories implement interfaces for testability

- Repositories handle only data access operations

- Use Eloquent models and relationships

- Avoid business logic in repositories



<code-snippet name="Repository Implementation" lang="php">

final readonly class UserRepository implements UserRepositoryInterface

{

    public function create(array $data): User

    {

        return User::create($data);

    }



    public function findByEmail(string $email): ?User

    {

        return User::where('email', $email)->first();

    }

}

</code-snippet>



### Adapter Layer Rules

- Adapters should be `final readonly` classes

- Adapters implement interfaces for testability

- Adapters handle external system integration (tokens, APIs, etc.)

- Use constructor property promotion for dependencies

- Keep adapters focused on single external system



<code-snippet name="Adapter Implementation" lang="php">

final readonly class PassportTokenAdapter implements TokenAdapterInterface

{

    public function getPasswordGrantToken(string $username, string $password): array

    {

        // Passport-specific token generation

    }



    public function refreshGrantToken(string $refreshToken): array

    {

        // Passport-specific token refresh

    }

}

</code-snippet>



### Interface Rules

- Place interfaces in appropriate Contracts/ subfolders

- Repository interfaces in `Repositories/Contracts/`

- Service interfaces in `Services/Contracts/`

- Adapter interfaces in `Adapters/Contracts/`

- Interfaces define clear contracts with proper type hints

- Use descriptive method names and PHPDoc blocks



<code-snippet name="Interface Definition" lang="php">

interface AuthServiceInterface

{

    /**

     * Đăng ký user mới và tạo token

     *

     * @return array<string, mixed>

     */

    public function register(string $name, string $email, string $password): array;

}

</code-snippet>



### Controller Rules

- Controllers should be `final` classes

- Controllers depend on service interfaces, not implementations

- Controllers handle only HTTP concerns (requests, responses, status codes)

- Use constructor property promotion for service injection

- Keep controllers thin - delegate to services



<code-snippet name="Controller Implementation" lang="php">

final class AuthController extends Controller

{

    public function __construct(

        private readonly AuthServiceInterface $authService,

    ) {

    }



    public function register(RegisterRequest $request): JsonResponse

    {

        $result = $this->authService->register(

            name: $request->name,

            email: $request->email,

            password: $request->password

        );



        return response()->json([

            'success' => true,

            'data' => $result,

        ], 201);

    }

}

</code-snippet>



### Service Provider Rules

- Register interfaces as singletons in `AppServiceProvider`

- Bind interfaces to implementations

- Use closure for complex dependency resolution

- Follow dependency injection best practices



<code-snippet name="Service Provider Registration" lang="php">

public function register(): void

{

    // Đăng ký repositories

    $this->app->singleton(UserRepositoryInterface::class, UserRepository::class);



    // Đăng ký adapters

    $this->app->singleton(TokenAdapterInterface::class, PassportTokenAdapter::class);



    // Đăng ký services

    $this->app->singleton(AuthServiceInterface::class, function ($app) {

        return new AuthService(

            $app->make(UserRepositoryInterface::class),

            $app->make(TokenAdapterInterface::class)

        );

    });

}

</code-snippet>



### Testing Rules

- Mock interfaces, not concrete implementations

- Test services independently with mocked dependencies

- Use factories for test data creation

- Test all happy paths, failure paths, and edge cases

- Services should be easily unit testable



### Benefits

- **Separation of Concerns** - Clear boundaries between layers

- **Testability** - Easy to mock interfaces for unit tests

- **Maintainability** - Changes isolated to specific layers

- **Reusability** - Services can be reused across controllers

- **SOLID Compliance** - Follows dependency inversion principle

</laravel-boost-guidelines>


# Reset Password Guide

## Endpoints
- POST `/api/forgot-password`
  - Body: `{ "email": "user@example.com" }`
  - Response: thành công sẽ gửi email chứa link reset.

- POST `/api/reset-password`
  - Body: `{ "email": "user@example.com", "token": "<token>", "password": "NewPass123", "password_confirmation": "NewPass123" }`

## Validation
- `password`: `required|string|min:6|confirmed` (đồng nhất với register/change-password)

## Email Reset URL
- Được tuỳ biến trong `App\Providers\AppServiceProvider` qua `ResetPassword::createUrlUsing`.
- Link: `${config('app.frontend_url')}/reset-password?token=<token>&email=<email>`

## Configuration
- `config/app.php`: thêm `frontend_url` lấy từ env `FRONTEND_URL` (fallback `APP_URL`).
- Thiết lập `.env`:
  - `FRONTEND_URL=http://localhost:3000` (ví dụ)
  - Mail SMTP (Mailtrap/Gmail/SES...) để gửi email.

## Database
- Yêu cầu bảng `password_reset_tokens` (đã có trong schema Postgres của dự án).

## Postman
- Collection `postman/BalanceFlow-API.postman_collection.json` đã có:
  - Forgot Password
  - Reset Password
- Biến `reset_token` để thử nhanh.

## Troubleshooting
- 404 khi mở link reset: set đúng `FRONTEND_URL` hoặc thêm route `GET /reset-password` ở backend để redirect sang frontend.
- Lỗi route `password.reset` không tồn tại: đã xử lý bằng `createUrlUsing`, chỉ cần clear cache nếu cần.

# Email Verification Guide

## Endpoints
- POST `/api/register` → tạo user và gửi email xác minh tự động
- GET `/api/verify-email/{id}/{hash}` → xác minh qua signed URL (middleware `signed`)
- POST `/api/email/verification-notification` → gửi lại email xác minh (Bearer token, throttle `6,1`)

## Hành vi
- `App\Models\User` implements `MustVerifyEmail`
- Sau đăng ký: gọi `sendEmailVerificationNotification()`
- Xác minh: so khớp `hash === sha1($user->getEmailForVerification())`, sau đó `markEmailAsVerified()`
- Đăng nhập: nếu chưa xác minh trả `403` với message i18n `messages.auth.verification_required`

## Cấu hình
- Đảm bảo cấu hình Mail trong `.env` để gửi email xác minh
- Có thể tuỳ biến URL xác minh để redirect về frontend tương tự phần Reset Password

## Bảo vệ route
- Hiện tại chỉ chặn tại bước login; token sau register vẫn có hiệu lực
- Nếu muốn buộc email đã xác minh ở các route quan trọng, thêm middleware `verified`

## Postman
- Đã thêm requests:
  - Verify Email (Signed URL)
  - Resend Verification Email
- Biến:
  - `verification_id`
  - `verification_hash`
